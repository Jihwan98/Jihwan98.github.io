---
title: "[CS] Chapter 04. CPU의 작동 원리"
author: JIHWAN PARK
categories: [Backend, CS]
tag: [Backend, CS]
math: true
date: 2023-08-27 17:14:04 +0900
last_modified_at: 2023-08-28 20:07:25 +0900
image: "https://github.com/Jihwan98/Jihwan98.github.io/assets/76936390/4e190150-96b0-438d-b2f2-35cff7fa4ea7"
---
> [혼자 공부하는 컴퓨터 구조 + 운영체제 (한빛미디어 출판, 강민철 지음)](https://www.hanbit.co.kr/store/books/look.php?p_code=B9177037040) 으로 공부한 내용을 정리합니다.<br>
> CS Study를 통해 함께 공부하고 있습니다. [[github repository]](https://github.com/aivle33-dev-study/cs-study)
{: .prompt-info}

## ✅ 04 - 1. ALU와 제어장치

> CPU의 구성 요소 중 ALU와 제어장치를 알아보자.<br>
> 핵심 키워드 : `ALU` `플래그` `제어장치` `제어 신호`
{: .prompt-info}

### ✔️ ALU
![image](/assets/posts/ALU.png)
_ALU가 어떤 정보를 받아들이고 내보내는지를 표현한 그림_

`ALU`는 레지스터를 통해 `피연산자`를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 `제어 신호`를 받아들인다. ALU는 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행한다.

연산을 수행한 결과
- 특정 숫자, 문자, 메모리 주소

이는 바로 메모리에 저장되지 않고 일시적으로 `레지스터`에 저장된다.

CPU가 메모리에 접근하는 시간은 레지스터에 접근하는 시간보다 훨씬 느리기 때문에 레지스터에 우선 저장한다.

ALU는 계산 결과와 더불어 `플래그(flag)`를 내보낸다. 연산 결과에 대한 추가적인 상태 정보를 의미. ALU가 내보내는 대표적인 플래그는 아래와 같다.

|플래그 종류|의미|사용 예시|
|---|---|---|
|부호 플래그|연산한 결과의 부호를 나타낸다.|1 : 계산 결과가 음수<br>0 : 계산 결과가 양수|
|제로 플래그|연산 결과가 0인지 여부를 나타낸다.|1 : 연산 결과가 0<br>0 : 연산 결과가 0이 아님|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.|1 : 올림수나 빌림수가 발생했음<br>0 : 올림수나 빌림수가 발생하지 않았음|
|오버플로우 플래그|오버플로우가 발생했는지를 나타낸다.|1 : 오버플로우가 발생<br>0 : 오버플로우가 발생하지 않음|
|인터럽트 플래그|인터럽트가 가능한지를 나타낸다.|1 : 인터럽트가 가능<br>0 : 인터럽트가 불가능|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.|1 : 커널모드로 실행 중<br>0 : 사용자 모드로 실행 중|

플래그들은 `플래그 레지스터`에 저장된다.

### ✔️ 제어장치

- `제어장치`는 제어 신호를 내보내고, 명령어를 해석하는 부품
- `제어 신호`는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

제어장치는 CPU의 구성 요소 중 가장 정교하게 설계된 부품

![image](/assets/posts/제어장치.png)
_제어장치가 무엇을 받아들이고, 무엇을 내보내는지 나타내는 그림_

<mark>제어 장치가 받아들이는 정보</mark>
- 클럭
- 명령어
- 플래그
- 제어 신호

1️⃣ 제어장치는 클럭 신호를 받아들인다.
: `클럭(clock)`이란 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위. 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들인다.

2️⃣ 제어장치는 '해석해야 할 명령어'를 받아들인다.
: CPU가 해석해야 할 명령어는 `명령어 레지스터`에 저장된다. 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

3️⃣ 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.
: 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

4️⃣ 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.
: 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어 장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.

<mark>제어장치가 내보내는 정보</mark>
- CPU 외부에 전달하는 제어 신호
- CPU 내부에 전달하는 제어 신호

**1️⃣ CPU 외부에 전달하는 제어 신호**

`메모리`에 전달하는 제어 신호 : 제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰기 위한 제어 신호

`입출력장치(보조기억장치)`로 전달하는 제어 신호 : 제어장치가 입출력장치(보조기억장치)의 값을 읽거나 입출력장치(보조기억장치)에 새로운 값을 쓰기 위한 제어 신호 

**2️⃣ CPU 내부에 전달하는 제어 신호**

`ALU`에 전달하는 제어신호 : 수행할 연산을 지시하기 위한 제어 신호

`레지스터`에 전달하는 제어 신호 : 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위한 제어 신호

## ✅ 04 - 2. 레지스터

> 레지스터의 종류와 역할을 학습하고, 각 레지스터를 통해 명령어가 처리되는 과정을 이해한다.<br>
> 핵심 키워드 : `프로그램 카운터` `명령어 레지스터` `메모리 주소/버퍼 레지스터` `범용/플래그 레지스터` `스택 포인터` `베이스 레지스터`
{: .prompt-info}

프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. 알아야 할 여덟 개의 레지스터는 아래와 같다.
1. [프로그램 카운터](#%EF%B8%8F-프로그램-카운터)
2. [명령어 레지스터](#%EF%B8%8F-명령어-레지스터)
3. [메모리 주소 레지스터](#%EF%B8%8F-메모리-주소-레지스터)
4. [메모리 버퍼 레지스터](#%EF%B8%8F-메모리-버퍼-레지스터)
5. [플래그 레지스터](#%EF%B8%8F-플래그-레지스터)
6. [범용 레지스터](#%EF%B8%8F-범용-레지스터)
7. 스택 포인터
8. 베이스 레지스터

### ✔️ 프로그램 카운터
`프로그램 카운터(PC: Program Counter)`는 메모리에서 가져올 명령어의 주소를 저장한다. `명령어 포인터(IP: Instruction Pointer)`라고 부르는 CPU도 있다.

### ✔️ 명령어 레지스터
`명령어 레지스터(IR: Instruction Register)`는 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

### ✔️ 메모리 주소 레지스터
`메모리 주소 레지스터(MAR: Memory Address Register)`는 메모리의 주소를 저장하는 레지스터이다. CPU가 읽어들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거친다.

### ✔️ 메모리 버퍼 레지스터
`메모리 버퍼 레지스터(MBR: Memory Buffer Register)`는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. `메모리 데이터 레지스터(MDR: Memory Data Register)`라고도 부른다.

### ✔️ 플래그 레지스터
`프래그 레지스터(flag register)`는 연산 결과 또는 CPU 상태에 대한 부가적ㅇ니 정보를 저장하는 레지스터이다.

### ✔️ 범용 레지스터
`범용 레지스터(general purpose register)`는 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다. 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다.

### ✔️ 주소 지정 방식 (1): 스택 주소 지정 방식
`스택 포인터(stack pointer)`는 `스택 주소 지정 방식`이라는 주소 지정 방식에 사용된다.

`스택 주소 지정 방식`은 스택과 스택 포인터를 이용한 주소 지정 방식이다. `스택 포인터`란 스택의 꼭대기를 가리키는 레지스터이다. 스택은 메모리 안에 스택처럼 사용할 영역으로 정해진 `스택 영역`에 있다.

### ✔️ 주소 지정 방식 (2): 변위 주소 지정 방식
`변위 주소 지정 방식(displacement addressing mode)`이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다.

![image](/assets/posts/변위%20주소%20지정%20방식.png)

변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 `상대 주소 지정 방식`, `베이스 레지스터 주소 지정 방식` 등으로 나뉜다.

#### 🔎 상대 주소 지정 방식
`상대 주소 지정 방식(relative addressing mode)`은 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다. 프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있다. 상대 주소 지정 방식은 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용된다.

#### 🔎 베이스 레지스터 주소 지정 방식
`베이스 레지스터 주소 지정 방식(base-register addressing mode)`은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다.

여기서 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다.

## ✅ 04 - 3. 명령어 사이클과 인터럽트

> CPU가 하나의 명령어를 처리하는 흐름인 명령어 사이클과 그 흐름을 방해하는 인터럽트에 대해 학습한다.<br>
> 핵심 키워드 : `명령어 사이클` `인터럽트` `예외` `하드웨어 인터럽트` `인터럽트 서비스 루틴`
{: .prompt-info}

### ✔️ 명령어 사이클
`명령어 사이클` : 명령어가 실행되는 일정한 주기. 하나의 명령어를 처리하는 정형화된 흐름
- `인출 사이클(fetch cycle)` : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- `실행 사이클(execution cycle)` : CPU로 가져온 명령어를 실행하는 단계. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
- `간접 사이클(indirect cycle)` : 명령어를 실행하기 위해 메모리 접근을 한 번 더 하는 단계

![image](/assets/posts/명령어%20사이클.png)
_명령어 사이클 도식_

### ✔️ 인터럽트
`인터럽트(interrupt)` : CPU의 작업을 방해하는 신호

인터럽트의 종류에는 크게 `동기 인터럽트`와 `비동기 인터럽트`가 있다.

#### 🔎 동기 인터럽트
`동기 인터럽트(synchronous interrupts)`는 CPU에 의해 발생하는 인터럽트이다. CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트이다. `예외(exception)`라고 부른다.

> **예외의 종류**<br>
> 예외의 종류에는 `폴트, 트랩, 중단, 소프트웨어 인터럽트`가 있다.
> - `폴트(fault)` : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개한다.
> - `트랩(trap)` : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개한다. 주로 디버깅할 때 사용한다.
> - `중단(abort)` : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외이다.
> - `소프트웨어 인터럽트(software interrupt)` : 시스템 호출이 발생했을 때 나타난다.
{: .prompt-tip}

#### 🔎 비동기 인터럽트
`비동기 인터럽트(asynchronous interrupts)`는 주로 입출력장치에 의해 발생하는 인터럽트이다. 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할을 한다.

일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 하는데, 해당 책에서는 용어의 혼동을 막기 위해 `하드웨어 인터럽트`라는 용어를 사용한다.

#### 🔎 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 `4`에서 백업해 둔 작업을 보구하여 실행을 재개한다.

- `인터럽트 요청 신호` : CPU에게 "지금 끼어들어도 되나요?"하고 물어보는 신호
- `인터럽트 플래그(interrupt flag)` : 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그. CPU가 인터럽트 요청을 수용하기 위해선 플래그 레지스터의 인터럽트 플래그가 활성화되어 있어야 한다.

> 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다.
> - 정전이나 하드웨어 고장으로 인한 인터럽트와 같이 막을 수 없는 인터럽트와, 막을 수 있는 인터럽트가 있다.
{: .prompt-tip}

- `인터럽트 서비스 루틴(ISR: Interrupt Service Routine)` : 인터럽트를 처리하기 위한 프로그램. `인터럽트 핸들러(interrupt handler)`라고도 부른다. 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
- `인터럽트 벡터(interrupt vector)` : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보

> 'CPU가 인터럽트를 처리한다'는 말은 '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다'는 말과 같다.
{: .prompt-tip}
