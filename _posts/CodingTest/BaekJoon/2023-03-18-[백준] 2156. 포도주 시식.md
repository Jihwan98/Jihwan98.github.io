---
title: "[백준] 2156. 포도주 시식(Python, 파이썬)"
author: JIHWAN PARK
categories: [Coding Test, BaekJoon]
tag: [Coding Test, BaekJoon, 다이나믹 프로그래밍]
math: true
date: 2023-03-18 19:37:02 +0900
last_modified_at: 2023-03-18 19:37:02 +0900
---
> 백준 온라인의 문제 풀이입니다.
{: .prompt-info}

## 📖 <a href='https://www.acmicpc.net/problem/2156' target='_blank'>[백준] 2156. 포도주 시식</a>

|시간 제한|메모리 제한|난이도|
|---|---|---|
|2초|128 MB|실버 1|

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

**✔️ 입력**

첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

**✔️ 출력**

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

**✔️ 입력 출력 예시**

|입력|출력|
|---|---|
|6<br>6<br>10<br>13<br>9<br>8<br>1|33|


## 🗒️ 내 풀이
n번 째 위치의 포도주를 마시지 않는 경우, 연속적으로 1번 마시는 경우, 2번 마시는 경우를 따로 보면 된다.

각 최대치를 구하는 방법을 보면,
- n번 째 위치의 포도주를 마시지 않는 경우 : n - 1 번 째의 최대치이다.
- n번 째 위치의 포도주를 연속적으로 1번 마시는 경우 : n - 1 번 째에서 마시지 않는 경우 + n 번째 포도주 양이다.
- n번 째 위치의 포도주를 연속적으로 2번 마시는 경우 : n - 1 번 째에서 연속적으로 1번 마신 경우 + n 번째 포도주 양이다.

dp[n][k]를 n번 째 포도주를 연속적으로 k번 마셨을 때의 최대치라고 하면, 점화식은 아래와 같다.

$$
\begin{align}
dp[n][0] = max(dp[n - 1]) \\
dp[n][1] += dp[n - 1][0] \\
dp[n][2] += dp[n - 1][1] \\
\end{align}
$$





```python
import sys
input = sys.stdin.readline
n = int(input())
dp = [[0] * 3 for _ in range(n)]
for i in range(n):
    k = int(input())
    for j in range(1, 3):
        dp[i][j] = k

# dp[n][0] = max(dp[n - 1])
# dp[n][1] += dp[n - 1][0]
# dp[n][2] += dp[n - 1][1]
for i in range(1, n):
    for j in range(3):
        if j == 0:
            dp[i][j] = max(dp[i - 1])
        else:
            dp[i][j] += dp[i - 1][j - 1]

print(max(dp[n - 1]))
```

![MinionsGIF](https://user-images.githubusercontent.com/76936390/225056853-6fd6c6e9-f78e-43c6-aea7-87f4da04a8f4.gif)